# 计网面试题

## HTTP通用头部

- Cache-Control: 用来指定当前的请求/回复中是否使用缓存机制 
  - no-store：客户端申请从源服务器得到数据   
- Connection: 客户端（浏览器）想要优先使用的连接类型，可以申请持久化连接
- Date: 报文创建时间

## HTTP请求头部

- Accept: 告诉服务器自己允许哪些媒体类型  
- Authorization: 用于表示 HTTP 协议中需要认证资源的认证信息  
- Host: 表示服务器的域名以及服务器所监听的端口号  
- User-Agent: 浏览器的身份标识字符串

## HTTP响应头部

- Accept-Ranges : 字段的值表示可用于定义范围的单位
- Location: 表示重定向后的 URL

## HTTP实体头部

- Content-encoding : 返回内容的编码方式
- Content-Length：返回内容的字节长度
- Content-Location：请求资源可替代的备用的另一地址
- Content-Type：返回内容的MIME类型
- Expires：响应过期的日期和时间
- Last-Modified ：请求资源的最后修改时间

## HTTP方法

- GET 请求指定的页面信息，并返回具体内容，通常只用于读取数据。
- HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头
- POST 向指定资源提交数据进行处理请求
- PUT 替换指定的资源，没有的话就新增
- DELETE 请求服务器删除 URL 标识的资源数据
- CONNECT 将服务器作为代理，让服务器代替用户进行访问
- OPTIONS 向服务器发送该方法，会返回对指定资源所支持的 HTTP 请求方法
- TRACE 回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断

GET和POST方法区别

> get 提交的数据会放在 URL 之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在 URL 中，可能会存在安全问题，因此往往用于获取资源信息。  
> post 参数放在请求主体中，并且参数不会被保留，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源  
> get 请求只支持 URL 编码，post 请求支持多种编码格式  
> get 只支持 ASCII 字符格式的参数，而 post 方法没有限制  
> get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据没限制

## HTTPS协议流程

- [image](../images/https.png)

## HTTPS和HTTP的区别

- HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差。HTTPS 数据传输过程是加密的，安全性较好。
- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 端口，后者是 443 端口。
- HTTPS 协议需要到数字认证机构（Certificate Authority, CA）申请证书，一般需要一定的费用。
- HTTP 页面响应比 HTTPS 快，主要因为 HTTP 使用 3 次握手建立连接，客户端和服务器需要握手 3 次，而 HTTPS 除了 TCP 的 3 次握手，还需要经历一个 SSL 协商过程

## HTTP保存用户状态

- 基于 Session 实现的会话保持

在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。

优点：安全性高，因为状态信息保存在服务器端。

缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。

【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】

- 基于 Cookie 实现的会话保持

当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。

优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。

缺点：该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。除此之外，浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽

## HTTP/1.1 和 HTTP/1.0 的区别

- 缓存处理：HTTP 1.1添加了更多缓存相关的字段
- 节约带宽：HTTP 1.1添加了range字段可以请求部分资源
- 错误管理的通知：新增了 24 个错误状态响应码
- 长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接

## HTTP/1.X 和 HTTP/2.0 的区别

- 2.0采用二进制传送
- 2.0支持多路复用
- 2.0头部压缩
- 2.0支持服务器推送

## HTTP3

HTTP/3 是在 QUIC 基础上发展起来的，其底层使用 UDP 进行数据传输，上层仍然使用 HTTP/2。在 UDP 与 HTTP/2 之间存在一个 QUIC 层，其中 TLS 加密过程在该层进行处理

- 使用 UDP 作为传输层进行通信
- 在 UDP 之上的 QUIC 协议保证了 HTTP/3 的安全性。QUIC 在建立连接的过程中就完成了 TLS 加密握手
- 建立连接快，正常只需要 1 RTT 即可建立连接。如果有缓存之前的会话信息，则直接验证和建立连接，此过程 0 RTT。建立连接时，也可以带有少量业务数据
- 不和具体底层连接绑定，QUIC 为每个连接的两端分别分配了一个唯一 ID，上层连接只认这对逻辑 ID。网络切换或者断连时，只需要继续发送数据包即可完成连接的建立
- 使用 QPACK 进行头部压缩，因为 在 HTTP/2 中的 HPACK 要求传输过程有序，这会导致队头阻塞，而 QPACK 不存在这个问题

## HTTP状态码

- 1XX	指示信息--表示请求正在处理   
  - 100 继续。客户端继续处理请求
- 2XX	成功--表示请求已被成功处理完毕  
  - 200 请求成功 
- 3XX	重定向--要完成的请求需要进行附加操作   
  - 301 永久移动
  - 302 临时移动
  - 304 未修改
  - 305 使用代理
- 4XX	客户端错误--请求有语法错误或者请求无法实现，服务器 无法处理请求   
  - 400 客户端请求的语法错误，服务器无法理解
  - 401 当前请求需要用户验证
  - 403 服务器已经理解请求，但是拒绝执行它
  - 404 请求失败，请求所希望得到的资源未被在服务器上发现
- 5XX	服务器端错误--服务器处理请求出现错误   
  - 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理
  - 502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应

状态码 301 和 302 的区别？

> 301：永久移动。请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。  
> 302：临时移动。与301类似，客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI

## TIME-WAIT 为什么是 2MSL

- 保证服务端的FIN报文收到相应ACK
- 避免前后两个使用相同四元组的连接中的前一个连接的报文干扰后一个连接

## 过多TIME_WAIT的处理方法

- 服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT 状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免 TIME-WAIT 状态。

- 也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高

## TCP协议中的定时器

- 建立连接定时器
- 重传定时器
- 坚持计时器：发送方使用一个坚持定时器来周期性地向接收方发送探测报文段，以查看接收方窗口是否变大
- 延迟应答计时器
- 保活定时器
- FIN_WAIT_2 定时器
- TIME_WAIT 定时器

## TCP可靠性

- 数据分块：应用数据被分割成 TCP 认为最适合发送的数据块。
- 序列号和确认应答
- 校验和
- 流量控制： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。
- 拥塞控制： 当网络某个节点发生拥塞时，减少数据的发送。
- ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
- 超时重传： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。

## UDP为什么不可靠

- UDP 只有一个 socket 接收缓冲区，没有 socket 发送缓冲区，即只要有数据就发，不管对方是否可以正确接收。而在对方的 socket 接收缓冲区满了之后，新来的数据报无法进入到 socket 接受缓冲区，此数据报就会被丢弃，因此 UDP 不能保证数据能够到达目的地，此外，UDP 也没有流量控制和重传机制，故UDP的数据传输是不可靠的。

- 和 TCP 建立连接时采用三次握手不同，UDP 中调用 connect 只是把对端的 IP 和 端口号记录下来，并且 UDP 可多多次调用 connect 来指定一个新的 IP 和端口号，或者断开旧的 IP 和端口号（通过设置 connect 函数的第二个参数）。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。

- 当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能

## 路由器和交换机的区别

- 工作层次不同：交换机主要工作在数据链路层（第二层）路由器工作在网络层（第三层）。
- 转发依据不同：交换机转发所依据的对象时：MAC地址。（物理地址）路由转发所依据的对象是：IP地址。
- 主要功能不同：交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。
- 交换机能做的，路由都能做。交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。
