我是xxx，来自HIT的大四，专业是xxx，基础知识方面学过操作系统，做过MIT的os实验，学过计网，看过TCP/IP详解
学过数据库基本理论，了解mysql，了解redis，主要语言是c++, 学过服务器相关的知识，了解过nginx，也去了解过相关中间件，做过一个web服务器

项目介绍：

通过HTTP协议与客户端进行通信，来接收，存储，处理来自客户端的HTTP请求，并对其请求做出HTTP响应，返回给客户端其请求的内容或返回一个Error信息，用mysql持久化账户密码和数据，采用定时器处理非活跃连接，采用日志记录服务器运行状态

项目架构：

事件处理模式默认采用Reactor模型，主线程采用IO多路复用负责连接/定时器/读写事件的监听，发生事件后，从线程池中获取工作线程进行执行，


项目难点：添加redis

https://dbaplus.cn/news-160-3389-1.html

可能的问题：

Reactor模式：
要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程（逻辑单元），将socket可读可写事件放入请求队列，交给工作线程处理

优点：解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制，更为显著的是对性能的提升，即不需要每个 Client 对应一个线程，减少线程的使用


Proactor模式
将所有的I/O操作都交给主线程和内核来处理（进行读、写），工作线程仅负责处理逻辑，如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool->append(users + sockfd)

IO复用模式

对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。
select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。
select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。
综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能

4天冲刺计划

goal ：滴滴sp面，中期答辩
preparation ：

- 操作系统：
  - epoll的et和lt
  - 共享内存
  - Linux相关命令
  - 缓存一致性协议
- 服务器：
  - 数据库
- 分布式
  - rpc
  - gfs
  - mapreduce
  - bigtable
  - raft
  - mapreduce
  - 一致性哈希
  - test-set-server
  - 脑裂
  - 分布式锁
- 数据库
- go
  - gc算法
  - grpc
- 计网
  - tcp&udp